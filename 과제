import pygame, sys, random
from pygame.locals import QUIT, KEYDOWN, K_ESCAPE , K_LEFT, K_RIGHT, K_DOWN, K_UP, K_SPACE, K_RETURN

pygame.init()

# 게임상태 정의
GAME_STATE_MENU = 0
GAME_STATE_RUNNING = 1
GAME_STATE_GAME_OVER = 2
GAME_STATE_QUIT = 3

# 기본 설정
block_size = 50 # 픽셀
GRID_WIDTH = 10  # 필드 넓이 (중앙 플레이 영역)
GRID_HEIGHT = 20  # 필드 높이
WIDTH_CELLS = GRID_WIDTH + 2 # 양쪽 벽 (10 + 2)
HEIGHT_CELL = GRID_HEIGHT + 1 # 바닥 (20 + 1)
FPS = 60

# 윈도우 창 사이즈
SCORE_BOARD = 6 * block_size # 6블록 크기의 점수판 영역 추가
WINDOW_WIDTH = WIDTH_CELLS * block_size + SCORE_BOARD # 12 * 50 + 300 = 900
WINDOW_HEIGHT = HEIGHT_CELL * block_size # 21 * 50 = 1050

SURFACE = pygame.display.set_mode([WINDOW_WIDTH, WINDOW_HEIGHT])  # 윈도우 창 가로,세로 크기
FPSCLOCK = pygame.time.Clock() # 초당 프레임 설정
pygame.display.set_caption("Pygame TETRIS") # 윈도우 창 이름설정

# 색상 정의
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GREY = (128, 128, 128)
LIGHT_GREY = (200, 200, 200)

# 블럭 색상
COLOR_RED = (255, 0, 0)
COLOR_GREEN = (0, 255, 0)
COLOR_BLUE = (0, 0, 255)
COLOR_YELLOW = (255, 255, 0)
COLOR_CYAN = (0, 255, 255)
COLOR_ORANGE = (255, 165, 0)
COLOR_PURPLE = (128, 0 ,128)

BLOCK_COLORS = [COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_CYAN, COLOR_ORANGE, COLOR_PURPLE]
WALL_COLOR = GREY


# 블럭 색과 모양 정의 (정식 테트리미노 기준)
TETOMINOES = {
    COLOR_CYAN: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], # I-블럭
    COLOR_YELLOW: [[1, 1], [1, 1]], # O-블럭
    COLOR_GREEN: [[0, 1, 1], [1, 1, 0], [0, 0, 0]], # S-블럭
    COLOR_RED: [[1, 1, 0], [0, 1, 1], [0, 0, 0]], # Z-블럭
    COLOR_BLUE: [[1, 0, 0], [1, 1, 1], [0, 0, 0]], # J-블럭
    COLOR_ORANGE: [[0, 0, 1], [1, 1, 1], [0, 0, 0]], # L-블럭
    COLOR_PURPLE: [[0, 1, 0], [1, 1, 1], [0, 0, 0]], # T-블럭
}

# 폰트 정의
FONT_SMALL = pygame.font.Font(None, 40)
FONT_MEDIUM = pygame.font.Font(None, 50)
FONT_LARGE = pygame.font.Font(None, 100)

# 전역 변수 초기화
FIELD = []
score = 0
game_over = False
fall_time = 0
fall_speed = 1000 # 1초마다 자동 하강
current_block = None

# 리셋 함수
def reset_game():
    global FIELD, score, game_over, current_block, fall_time

    # 필드 정의 (벽 및 바닥 초기화)
    FIELD = [[0 for x in range(WIDTH_CELLS)] for y in range(HEIGHT_CELL)] # 테트리스 필드 영역
    for y in range(HEIGHT_CELL):
        FIELD[y][0] = WALL_COLOR # 왼쪽 벽
        FIELD[y][WIDTH_CELLS - 1] = WALL_COLOR # 오른쪽 벽
    for x in range(WIDTH_CELLS):
        FIELD[HEIGHT_CELL - 1][x] = WALL_COLOR # 바닥

    # 변수 리셋
    score = 0
    game_over = False
    fall_time = 0

    # 새 블럭 생성
    current_block = Block()

class Block:  # 블럭과 블럭의 움직임 구현
    def __init__(self):
        # 무작위 블록 타입 선택
        self.color, block_shape = random.choice(list(TETOMINOES.items()))
        self.block = block_shape

        # 시작 좌표 지정: 필드 중앙 상단 (벽 제외한 1~10칸)
        block_width = len(self.block[0])
        start_x = (GRID_WIDTH // 2) - (block_width // 2)
        self.x = 1 + start_x # 시작 위치를 중앙으로 조정 (벽을 고려하여 +1)
        self.y = 0
        self.rotation = 0

    def rotate(self): # 벽 및 다른 블럭과 충돌하는지 체크 하고 블럭을 회전
        # 블럭 회전
        rotated_block = list(map(list, zip(*self.block[::-1])))
        
        # 회전 후 충돌 검사
        if not self.check_collision(self.x, self.y, rotated_block):
            self.block = rotated_block
            self.rotation = (self.rotation + 1) % 4

    def move_left(self):
        if not self.check_collision(self.x-1, self.y, self.block):
            self.x -= 1

    def move_right(self):
        if not self.check_collision(self.x+1, self.y, self.block):
            self.x += 1

    def move_down(self):
        # 한 칸 아래로 이동했을 때 충돌 검사
        if not self.check_collision(self.x, self.y + 1, self.block):
            self.y += 1
            return False
        else:
            self.lock_block()
            return True # 충돌 했을 때 고정

    def hard_drop(self): # 블럭을 끝까지 내리고 고정
        drop_distance = 0
        # 충돌 직전까지 y좌표 찾기
        while not self.check_collision(self.x, self.y + drop_distance + 1, self.block):
            drop_distance += 1
        
        self.y += drop_distance
        
        if drop_distance > 0: 
            self.lock_block()
            return True
        return False # 이동 없이 바로 고정될 경우
    
    def lock_block(self): # 필드에 블럭을 고정
        for i in range(len(self.block)):
            for j in range(len(self.block[0])):
                if self.block[i][j]:
                    x = self.x + j
                    y = self.y + i
                    # y >= 0 일 때만 필드에 고정
                    if 0 <= y < HEIGHT_CELL and 0 <= x < WIDTH_CELLS:
                        FIELD[y][x] = self.color

    def check_collision(self, x, y, block):
        for i in range(len(block)):
            for j in range(len(block[0])):
                if block[i][j]:
                    grid_x = x + j
                    grid_y = y + i
                    
                    # grid_y가 음수일 때 (화면 밖 위쪽)는 충돌 검사를 무시
                    if grid_y >= 0:
                        # 0 <= grid_y < HEIGHT_CELL와 0 <= grid_x < WIDTH_CELLS는 이미 벽으로 처리되어 있으므로
                        # FIELD[grid_y][grid_x] != 0 검사만으로 벽, 바닥 및 고정된 블럭과의 충돌이 처리됨
                        if FIELD[grid_y][grid_x] != 0: # 벽(WALL_COLOR) 또는 고정된 블럭(색상)과 충돌
                            return True
        return False
      
    # 블럭 그리기
    def draw(self):
        for i in range(len(self.block)):
            for j in range(len(self.block[0])):
                if self.block[i][j]:
                    # 블럭과 필드 그리기
                    screen_x = block_size * (self.x + j)
                    screen_y = block_size * (self.y + i)
                    
                    # 블록 내부 채우기
                    pygame.draw.rect(SURFACE, self.color, [screen_x, screen_y, block_size, block_size], 0)
                    
                    # 블럭 경계선 그리기
                    pygame.draw.rect(SURFACE, BLACK, [screen_x, screen_y, block_size, block_size], 1)

# 게임 로직
def check_line(): # 라인이 가득찼는지 체크하고 지우고 위쪽 라인을 내린다
    global score
    lines_cleared = 0
    y = HEIGHT_CELL - 2 # 바닥 바로 윗줄부터 시작 (GRID_HEIGHT - 1)

    while y > 0:
        # 1부터 WIDTH_CELLS - 2 (왼쪽 벽 다음부터 오른쪽 벽 전까지)
        if all(FIELD[y][x] != 0 for x in range(1, WIDTH_CELLS - 1)):
            lines_cleared += 1

            # 해당 라인 위쪽의 모든 블록을 내림 (y부터 1번째 줄까지)
            for k in range(y, 1, -1):
                FIELD[k] = FIELD[k - 1][:] # 윗줄을 현재 줄로 복사

            # 최상단 라인 (인덱스 1)을 빈 라인으로 만듦
            FIELD[1] = [WALL_COLOR] + [0] * GRID_WIDTH + [WALL_COLOR]
        else:
            y -= 1 # 라인이 채워지지 않았으면 위쪽 라인 체크

    # 점수 계산
    if lines_cleared == 1: 
        score += 100
    elif lines_cleared == 2:
        score += 300
    elif lines_cleared == 3:
        score += 500
    elif lines_cleared >= 4:
        score += 800
    
    return lines_cleared

def draw_field(): # 필드와 고정된 블럭 그리기
    for i in range(HEIGHT_CELL):
        for j in range(WIDTH_CELLS):
            color = FIELD[i][j]
            if color:
                screen_x = block_size * j
                screen_y = block_size * i 
                
                # 블록 내부 채우기
                pygame.draw.rect(SURFACE, color, [screen_x, screen_y, block_size, block_size], 0)

                # 블럭 경계선 
                if color != WALL_COLOR:
                    pygame.draw.rect(SURFACE, BLACK, [screen_x, screen_y, block_size, block_size], 1)

def draw_score(current_score): # 점수판 그리기
    pygame.draw.rect(SURFACE, BLACK, [600, 0, SCORE_BOARD, WINDOW_HEIGHT]) # 점수 영역 배경
    pygame.draw.rect(SURFACE, GREY, [600, 0, SCORE_BOARD, WINDOW_HEIGHT], 10) # 경계 표시
    
    font = pygame.font.Font(None, 48)
    score_label = font.render("SCORE", True, WHITE) # SCORE 글자 표시
    text_score = font.render(str(current_score), True, COLOR_YELLOW) # 실제 점수 표시
    
    # 점수판 텍스트 위치 계산
    center_x = 600 + SCORE_BOARD // 2
    
    SURFACE.blit(score_label, (center_x - score_label.get_width() // 2, 50)) # SCORE 글자 위치 계산
    
    SURFACE.blit(text_score, (center_x - text_score.get_width() // 2, 100)) # 점수 위치 계산
    
# 메뉴 화면 그리기
def draw_menu_text(text, font, color, x, y):
    text_surface = font.render(text, True, color)
    text_rext = text_surface.get_rect(center=(x,y))
    SURFACE.blit(text_surface, text_rext)

def main_menu():#메인 메뉴
    menu_items = ["Start", "Option", "Exit"]
    selected_item_index = 0

    center_x = WINDOW_WIDTH // 2 # 화면 중간 좌표 정의
    item_spacing = 80 # 메뉴 항목 간격 정의

    while True:
        for event in pygame.event.get():
            if event.type == QUIT or (event.type == KEYDOWN and event.key == K_ESCAPE):
                return GAME_STATE_QUIT # ESC를 누르면 게임 끄기
            
            if event.type == KEYDOWN: # 메뉴 이동 및 선택
                if event.key == K_UP:
                    selected_item_index = (selected_item_index - 1) % len(menu_items)
                elif event.key == K_DOWN:
                    selected_item_index = (selected_item_index + 1) % len(menu_items)
                
                # K_RETURN 또는 K_SPACE로 선택 확정
                elif event.key == K_RETURN or event.key == K_SPACE: 
                    if selected_item_index == 0:
                        reset_game()
                        return GAME_STATE_RUNNING
                    elif selected_item_index == 1:
                        # 설정 메뉴는 현재 구현되지 않음
                        pass 
                    elif selected_item_index == 2:
                        return GAME_STATE_QUIT
                    
        SURFACE.fill(BLACK)

        title_y = WINDOW_HEIGHT // 4
        draw_menu_text("TETRIS", FONT_LARGE, COLOR_GREEN, center_x, title_y)

        start_y = WINDOW_HEIGHT // 2
        
        for i, item in enumerate(menu_items): # enumerate 함수를 이용해 메뉴 인덱스의 값을 정의
            color = WHITE if i == selected_item_index else GREY # 현재 선택된 메뉴를 흰색, 선택되지 않은 메뉴를 회색으로 설정
            font = FONT_MEDIUM if i == selected_item_index else FONT_SMALL # 선택된 메뉴를 그렇지 않은 메뉴보다 크게 설정
            draw_menu_text(item, font, color, center_x, start_y + i * item_spacing)


        pygame.display.update()
        FPSCLOCK.tick(FPS) 
        
def game_loop():
    global current_block, fall_time, game_over, score         

    while True:
        for event in pygame.event.get():  #이벤트 처리
            if event.type == QUIT or (event.type == KEYDOWN and event.key == K_ESCAPE):
                return GAME_STATE_QUIT 

            #게임오버가 아닐 때만 키 입력처리
            if not game_over and event.type == KEYDOWN:
                if event.key == K_LEFT: # 왼쪽 방향키를 눌렀을 때 블럭이 왼쪽으로 움직임
                    current_block.move_left()
                    
                elif event.key == K_RIGHT:# 오른쪽 방향키를 눌렀을 때 블럭이 오른쪽으로 움직임
                    current_block.move_right()

                elif event.key == K_DOWN:# 아래쪽 방향키를 눌렀을 때 블럭이 아래쪽으로 움직임
                    if current_block.move_down(): # 블럭이 고정된 경우
                        check_line()
                        current_block = Block()
                        if current_block.check_collision(current_block.x, current_block.y, current_block.block) :
                            game_over = True
                    
                    # 블럭을 아래로 움직일 때마다 자동 하강 시간을 초기화
                    fall_time = 0 

                elif event.key == K_UP:# 위쪽 방향키를 눌렀을 때 블럭이 회전함
                    current_block.rotate()

                elif event.key == K_SPACE:# 드롭 실행 및 블록 고정
                    if current_block.hard_drop(): # 하드 드롭 후 블록이 고정되면 True 반환
                        check_line() # 드롭 후 라인 체크   
                        current_block = Block() # 새 블럭 생성

                        # 새 블럭 생성 후 즉시 충돌 체크
                        if current_block.check_collision(current_block.x, current_block.y, current_block.block):
                            game_over = True
                            
                    fall_time = 0 # 하드 드롭 후에도 시간 초기화

        fall_time += FPSCLOCK.get_time()
        
        # 점수에 따른 낙하 속도 조절
        current_fall_speed = 1000 # 기본 속도
        if score < 500:
            current_fall_speed = 1000
        elif score < 1000:
            current_fall_speed = 800
        elif score < 1500:
            current_fall_speed = 600
        elif score < 2000:
            current_fall_speed = 400
        else:
            current_fall_speed = 200 

        if fall_time >= current_fall_speed:
            if current_block.move_down():
                # 블럭이 고정됐을때 라인 검사
                check_line()

                # 새 블럭 생성 및 게임 오버 검사
                current_block = Block()
                if current_block.check_collision(current_block.x, current_block.y, current_block.block):
                    game_over = True
            
            fall_time = 0 # 시간 초기화


        pygame.draw.rect(SURFACE, BLACK, [0, 0, WIDTH_CELLS * block_size, WINDOW_HEIGHT])
        draw_field()#필드와 고정된 블럭 그리기
        draw_score(score) # 점수판 그리기 함수 호출

        if not game_over:
            current_block.draw()

        # 게임 오버 화면 표시 (게임 루프 내부에 있을 필요는 없으나, 현재 구조를 따름)
        if game_over:
            return GAME_STATE_GAME_OVER

        pygame.display.update()
        FPSCLOCK.tick(FPS)

def game_over_screen():
    pygame.time.delay(200) # 게임오버 화면으로 넘어가기 전 약간의 딜레이

    while True:
        for event in pygame.event.get():
            if event.type == QUIT or (event.type == K_DOWN and event.key == K_ESCAPE):
                return GAME_STATE_QUIT
            if event.type == KEYDOWN and (event.key == K_RETURN or event.key == K_SPACE):
                return GAME_STATE_MENU # 엔터나 스페이스를 눌러 메인메뉴로 돌아가기
            
        SURFACE.fill(BLACK) # 배경 검은색으로 채우기

        draw_menu_text("GAME OVER", FONT_LARGE, COLOR_RED, WINDOW_WIDTH // 2, WINDOW_HEIGHT // 3)

        draw_menu_text(f"SCORE : {score}", FONT_MEDIUM, WHITE, WINDOW_WIDTH // 2, WINDOW_HEIGHT // 3 + 120)

        draw_menu_text("ENTER/SPACE", FONT_SMALL, GREY, WINDOW_WIDTH // 2, WINDOW_HEIGHT // 3 + 250)

        pygame.display.update()
        FPSCLOCK.tick(FPS)
        
def main():
    game_state = GAME_STATE_MENU

    while game_state != GAME_STATE_QUIT:
        if game_state == GAME_STATE_MENU:
            game_state = main_menu()

        elif game_state == GAME_STATE_RUNNING:
            game_state = game_loop()

        elif game_state == GAME_STATE_GAME_OVER:
            game_state = game_over_screen()
    
    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()
